<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mouse Control Model</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        #webgl-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: sans-serif;
            font-size: 1.2em;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 20;
        }
    </style>
</head>
<body>

    <div id="webgl-canvas"></div>

    <div id="instructions">
        **Instructions:** Move your mouse over the screen to rotate the cube!
        <br>It rotates based on your cursor's position.
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, cube;
        // Variables to store mouse position (normalized from -1 to 1)
        let targetRotationX = 0;
        let targetRotationY = 0;
        
        // --- THREE.JS SETUP ---
        function initThreeJS() {
            // Setup skipped for brevity (same as before)

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x111111 ); // Dark background
            
            // Camera (Perspective, looking out)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('webgl-canvas').appendChild(renderer.domElement);
            
            // Cube Model
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshPhongMaterial({ color: 0x00ffff, wireframe: false }); 
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 1, 1).normalize();
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);
            // NEW: Add Mouse Listener
            document.addEventListener('mousemove', onDocumentMouseMove, false);
        }

        function onWindowResize() {
            // ... (Same as before)
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- MOUSE CONTROL LOGIC ---
        function onDocumentMouseMove(event) {
            // Normalize mouse X position (0 to window width) to a target rotation (-1 to 1)
            targetRotationY = (event.clientX / window.innerWidth) * 2 - 1;

            // Normalize mouse Y position (0 to window height) to a target rotation (-1 to 1)
            // We invert the Y control here for a more natural feel
            targetRotationX = (event.clientY / window.innerHeight) * 2 - 1;
        }

        // --- ANIMATION LOOP (Replaces the Webcam Loop) ---
        function animate() {
            requestAnimationFrame(animate);

            // Smoothly move the cube's rotation towards the target mouse rotation
            // The 0.1 is the damping factor for smooth movement
            cube.rotation.y += (targetRotationY * Math.PI - cube.rotation.y) * 0.05;
            cube.rotation.x += (targetRotationX * Math.PI * 0.5 - cube.rotation.x) * 0.05;

            renderer.render(scene, camera);
        }

        // --- INITIALIZATION ---
        function run() {
            initThreeJS();
            animate();
        }

        run();
    </script>

</body>
</html>
